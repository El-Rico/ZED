#ifndef __ZED_RENDERER_VERTEXATTRIBUTES_HPP__
#define __ZED_RENDERER_VERTEXATTRIBUTES_HPP__

#include <System/DataTypes.hpp>
#include <vector>

namespace ZED
{
	enum VERTEXATTRIBUTE_TYPE
	{
		VERTEXATTRIBUTE_TYPE_FLOAT1 = 0,
		VERTEXATTRIBUTE_TYPE_FLOAT2,
		VERTEXATTRIBUTE_TYPE_FLOAT3,
		VERTEXATTRIBUTE_TYPE_FLOAT4,
		VERTEXATTRIBUTE_TYPE_MAT2X2,
		VERTEXATTRIBUTE_TYPE_MAT3X3,
		VERTEXATTRIBUTE_TYPE_MAT4X4,
		VERTEXATTRIBUTE_TYPE_UNKNOWN = ZED_ENUM_PADDING
	};

	enum VERTEXATTRIBUTE_INTENT
	{
		VERTEXATTRIBUTE_INTENT_POSITION = 0,
		VERTEXATTRIBUTE_INTENT_NORMALS,
		VERTEXATTRIBUTE_INTENT_COLOUR,
		VERTEXATTRIBUTE_INTENT_TEXTURECOORDINATES,
		VERTEXATTRIBUTE_INTENT_TANGENTVECTOR,
		VERTEXATTRIBUTE_INTENT_BINORMALVECTOR,
		VERTEXATTRIBUTE_INTENT_TANGENTMATRIX,
		VERTEXATTRIBUTE_INTENT_BLENDWEIGHT,
		VERTEXATTRIBUTE_INTENT_BLENDINDEX,
		VERTEXATTRIBUTE_INTENT_UNKNOWN = ZED_ENUM_PADDING
	};

	typedef struct __zedVERTEXATTRIBUTE
	{
		VERTEXATTRIBUTE_TYPE	Type;
		VERTEXATTRIBUTE_INTENT	Intent;
	}VERTEXATTRIBUTE;

	namespace Renderer
	{
		class VertexAttributes
		{
		public:
			ZED_EXPLICIT VertexAttributes(
				ZED_MEMSIZE p_MaximumVertexAttributeCount );
			~VertexAttributes( );

			ZED_UINT32 AddVertexAttribute( const VERTEXATTRIBUTE_TYPE p_Type,
				const VERTEXATTRIBUTE_INTENT p_Intent );

			ZED_UINT32 GetVertexAttributeAt( const ZED_MEMSIZE p_Index,
				VERTEXATTRIBUTE &p_VertexAttributeOut ) const;

			ZED_MEMSIZE GetVertexAttributeCount( ) const;
			ZED_UINT32 GetVertexAttributes(
				VERTEXATTRIBUTE *p_pVertexAttributes ) const;

			ZED_MEMSIZE GetVertexStride( ) const;

		private:
			ZED_MEMSIZE						m_VertexStride;
			ZED_MEMSIZE						m_MaximumVertexAttributeCount;
			std::vector< VERTEXATTRIBUTE >	m_VertexAttributes;
		};

		ZED_MEMSIZE ConvertVertexAttributeToSize(
			const VERTEXATTRIBUTE &p_Attribute );
		ZED_MEMSIZE ConvertVertexAttributeToElementCount(
			const VERTEXATTRIBUTE &p_Attribute );
	}
}

#endif // __ZED_RENDERER_VERETXATTRIBUTES_HPP__

